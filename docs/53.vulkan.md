<div class="REY_ACADEMIA1">

### So, where do we start?
- well, there's no "java native" vulkan implementation
- there is `lwjgl`
    - _**LightWeight java Game Library**_
    - wrapper on top on OpenGL, Vulkan, OpenAL, OpenCL etc

### `lwjgl` Convention #1: `.calloc()`
- All "Vulkan Info Structures" has to be created with a `.calloc()` / `.malloc()`
    ```java
    VkApplicationInfo info = VkApplicationInfo.calloc();
    ```
    - `.calloc()`: **Zero-Initialized**
    - `.malloc()`:   **Un-Initialized**
        - **Un-Initialized**: it contains whatever data was previously in that memory location
        - **When to Use**: You can use this if you are absolutely certain you will overwrite every single byte of the allocated memory, as it's theoretically slightly faster since it skips the zeroing step. However, if you miss setting any field, you introduce a serious bug from garbage data.
        - **In Vulkan, this is risky.**
        <div class="BR3"></div>

- wait, wait, so, ü§î is it allocated on the **heap**? or on the **stack**?
    ```java
    VkApplicationInfo info = VkApplicationInfo.calloc();
        // OS Heap - we gotta free manually
    
    org.lwjgl.system.MemoryStack mStack = MemoryStack.stackPush();
    VkApplicationInfo            info   = VkApplicationInfo.calloc(mStack);
        // Stack
        // oorrr, is it so? ü§î
    ```
    1. `lwjgl.MemoryStack mStack`
        - The instanced object itself will be created on the **"java Heap"**
    2. **java Heap** != **OS Heap**
    3. **C++ Stack Memory**
        - a fixed region of RAM reserved by the OS for each thread of CPU.
    4. `MemoryStack.stackPush()`
        - allocates/hands us some **Heap** from **DRAM** to hold our `VkApplicationInfo` & others....
        - might be a piece of some preallocated big-chunk of **Heap** üíÅ‚Äç‚ôÄÔ∏è 
    5. `MemoryStack`: 
        - ‚Äú**OS heap** memory pretending to behave like **stack** memory.‚Äù
        - **LWJGL** ‚Äúartificially‚Äù recreates what **C++ Stack Memory** does automatically
        - fast & temporary
        - auto released on `mStack.pop()` / `mStack.close()`
    ```java
    org.lwjgl.system.MemoryStack mStack = MemoryStack.stackPush();
    VkApplicationInfo            info   = VkApplicationInfo.calloc(mStack);
        // *Emulated Stack + OS-Heap UnderTheHood
    ```
    <div class="BR3"></div>

### `lwjgl` Allocation Confusions
- does it mean, `mStack` will be freed **"automatically"** when it goes out of scope?
    1. Well **java** doesn't have the concept of **Object Destructors** 
    2. So, when `mStack` goes out of scope
        - `mStack` simply becomes unreachable
        - the memory we got from `MemoryStack.stackPush()` is not **freed/popped**
    3. the **"java way"** instead is:
        - to call `mStack.close()` - not encouraged
        - **"try-with-resources"** feature of **java**  
        ```java
        try(org.lwjgl.system.MemoryStack mStack  = MemoryStack.stackPush()) {
            VkApplicationInfo            appInfo = VkApplicationInfo.calloc(mStack);
        } // mStack.close() auto-called here ‚Üí memory popped safely
        ```
        <div class="BR3"></div>

- why is this discouraged
    ```java
    org.lwjgl.system.MemoryStack mStack = MemoryStack.stackPush();
    VkApplicationInfo            info   = VkApplicationInfo.calloc(mStack);
    mStack.close();
    ```
    - because, in here, if any exception is throwed,
    - then, JVM will just, skip to the **"nearest catch"** or **"end the program"**.
    - so, like, `mStack.close()` would be skipped in that case
    <div class="BR3"></div>

- **"try-with-resources"** under-the-hood
    ```java
    MemoryStack mStack = MemoryStack.stackPush();
    Throwable excepRef = null;

    try {
        VkApplicationInfo info = VkApplicationInfo.calloc(mStack);
        // ... some Vulkan setup code ...
    } catch (Throwable ref1) {
        excepRef = ref1;
        throw excepRef;                 // rethrow it later, after processing "finally" block
    } finally {
        if (mStack != null) {           // why mStack? why not some other variable?
            if (excepRef != null) {         // because MemoryStack was created inside try(...)
                try {
                    mStack.close();
                } catch (Throwable excep2) {
                    excepRef.addSuppressed(excep2);
                }
            } else {
                mStack.close();         // no exception, close normally
            }
        }
    }
    ``` 

</div>