### class
1. https://www.youtube.com/watch?v=2BP8NhxjrO0
2. https://www.youtube.com/watch?v=fLgTtaqqJp0
3. https://www.youtube.com/watch?v=3dHBFBw13E0
4. Constructors: https://www.youtube.com/watch?v=FXhALMsHwEY
5.  Destructors: https://www.youtube.com/watch?v=D8cWquReFqw

### `public/private` a.k.a _**inheritence**_
1. https://www.youtube.com/watch?v=X8nYM8wdNRE

### `static`
1. https://www.youtube.com/watch?v=f3FVU-iwNuA
2. https://www.youtube.com/watch?v=V-BFlMrBtqQ

### JVM (Java Virtual Machine)
1. It emulates a computer (a virtual machine), handling things like:
    - class loading,
    - memory allocation,
    - garbage collection,
    - JIT compilation,
    - thread management, etc.

### Memory Types in java
1.  **java Heap**
    - ==> JVM's Managed Heap
    - allocated by **JVM**
    - managed by **GC** (Garbage Collector)
    - where normal java objects live, e.g. `new Foo()` 

2. **C/C++ Heap**
    - ==> malloc-style Heap 
    - ==> Native Heap -> JNI/C world
    - ==> off-Heap -> (JVM/Java People) 
        - the Java-side term meaning ‚Äúoutside the JVM‚Äôs managed heap.‚Äù
    - ==> OS Heap
        - the actual heap region that the OS gives to native code (via `malloc()`, `VirtualAlloc()`, etc.).
        - "**native code**" = C/C++
    - 
    - memory region allocated by the Operating System directly
    - outside the java Heap
    - not under java's GC control 
    - libraries like `lwjgl` or `jni` call into **C code**, as in, calls `malloc()` or `calloc()` and gets memory directly from the OS

3. **C++ Stack Memory**
    - a fixed region of **RAM** reserved by the **OS** for each **thread of CPU**.

4. **JVM Stack**
    - JVM call frames (one per thread)
    - For local vars, return addresses
        - int, float, double, boolean, byte, short, char, long
        - Object Reference/Pointers
        ```java
        void foo() {
            int x = 5;           // primitive, lives on stack
            String s = "Hello";  // reference on stack, object in heap
        }
        ```

5. `lwjgl.system.MemoryStack`
    - A chunk of native heap memory
    - Artificially Behaves like a LIFO stack allocator

### object creation / object instance
1. In `java`, object must be created via `new` (or reflection, deserialization, JNI, etc.)
    ```java
    MyClass obj;    // just declaration
        // this is not creating an object at all
        // it will just be a null reference
    ```
    - So in the end, Objects can only be on **java heap**
2. Even Small Structs can't be on Stack
    ```cpp
        // C/C++
    void f() {
        struct Point p = {1, 2};  // on stack
    }
    ``` 
    ```java
        // java
    record Point(int x, int y) {}
    Point p = new Point(1, 2);  // always on the Java Heap
    ```
    - Java doesn‚Äôt expose control over stack vs heap placement ‚Äî everything is reference-based and heap-allocated.
    - That said: üîú **Project Valhalla** (still under development) is planning to add value types (no object identity, stack-allocatable).
3. Local variables (primitives, references) are stored on the JVM stack
4. When we instance/create an java object from a class, it is allocated on the **"java Heap"**
5. `finalize()` class method/function was once a fallback
    - but this is deprecated and discouraged (since Java 9+)
    - It‚Äôs non-deterministic ‚Äî it could run seconds, minutes, or never.

### AutoCloseable classes

### Exception
- Exceptions don‚Äôt ‚Äúcrash‚Äù the JVM ‚Äî they just skip to the nearest catch or end the program.
- But they do skip all remaining lines in the current block.

### üß© Additional (less-talked-about) Memory Regions
5. **Metaspace**
    - Stores class metadata (replaced the old PermGen)
    - Grows dynamically in native memory
    - Holds method bytecode, field info, etc.

6. **Code Cache**
    - Holds JIT-compiled machine code
    - Managed by the JVM‚Äôs HotSpot compiler

7. **Thread-local / Native Stack**
    - The *real* OS-level C stack for each thread
    - Used internally when native functions are called

8. **Direct Byte Buffers**
    - Off-heap buffers allocated using `ByteBuffer.allocateDirect()`
    - Backed by native memory (outside GC)
    - Often used for high-performance I/O and graphics

### `native` marked functions
- The keyword `native` in a `java` (method/function signature) means that the method's implementation is not written in `java` but is provided in a platform-specific native library, typically written in another language like `C or C++`.
    - Gemini 2.5 Flash, October 24, 2025
- This mechanism is called the Java Native Interface (JNI)
- The actual logic for that method is implemented in an external, compiled library (a .dll on Windows, .so on Linux, or .dylib on macOS).
- Purpose:
    - To allow Java code to call functions written in native languages (like C/C++), enabling access to platform-specific features, hardware, or achieving high performance where Java may be less efficient (as is the case with LWJGL's memory and graphics calls).
- Example:
    - Vulkan SDK implementation are done by LunarG + nVidia/AMD/intelARC/SnapDragon/AppleMProcessors/etc
        - & That is done in C/C++
        - java cannot be like, we are gonna maintain this big of a thing on our own, in java.
        - VULKAN's Actual Function Implementations:
            - are done by the GPU Manufacturer Company (say nVidia/AMD-Radeon/intel-ARC/Apple-M/SnapDragon-Adreno/etc
            - shipped inside .dll / .so
            - some people don't release their source, so it's just there in your OS, after you install the Driver Software, inside a .dll / .so file
        - say, 
            - we imeplement `VkApplicationInfo` in `java`, 
            - create an object-instance from it 
            - & take the memory pointer of it 
            - & then pass it to the GPU Driver Implemented VULKAN Function (inside .dll / .so)
                - now, that function expects a pointer to a precise memory "layout" (the C struct). 
                - & The Java object's layout is incompatible with this expectation. ü§∑‚Äç‚ôÄÔ∏è
        - lwjgl
            - tackled this by calling C/C++ implementation of calloc()/malloc()
            - and yes, memory can be calloced/malloced both on stack/heap